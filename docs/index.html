<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <title>Biomedical Knowledge Graph</title>
  <link rel="stylesheet" href="https://unpkg.com/vis-network/styles/vis-network.min.css">
  <style>
    :root {
      --bg: #f5f7f8;
      --card: #ffffff;
      --border: #dddddd;
      --text: #111111;
      --muted: #666666;
      --blue: #1677ff;
    }
    body {
      margin: 0;
      background: var(--bg);
      color: var(--text);
      font-family: Helvetica, Arial, sans-serif;
    }
    .bar {
      padding: 10px 12px;
      background: var(--card);
      border-bottom: 1px solid var(--border);
      position: sticky;
      top: 0;
      z-index: 10;
    }
    .row {
      display: flex;
      flex-wrap: nowrap;
      align-items: center;
      gap: 10px;
      overflow-x: auto;
    }
    label {
      font-size: clamp(13px, 1.2vw, 19px);
      display: inline-flex;
      align-items: center;
      gap: 6px;
      white-space: nowrap;
      font-weight: 600;
      flex: 0 0 auto;
    }
    input {
      padding: 5px 8px;
      font-size: clamp(12px, 1vw, 14px);
      border: 1px solid #d0d0d0;
      border-radius: 6px;
      min-width: 88px;
      line-height: 1.1;
    }
    input[type="number"] {
      width: 90px;
    }
    input[type="text"] {
      width: 230px;
    }
    button {
      padding: 6px 14px;
      border-radius: 8px;
      border: 1px solid var(--blue);
      background: var(--blue);
      color: #fff;
      font-size: clamp(12px, 1vw, 14px);
      font-weight: 600;
      cursor: pointer;
      flex: 0 0 auto;
    }
    .hint {
      font-size: 12px;
      color: var(--muted);
      white-space: nowrap;
      flex: 0 0 auto;
    }
    .count {
      font-size: 12px;
      color: #222;
      font-weight: 600;
      white-space: nowrap;
      flex: 0 0 auto;
    }
    #network {
      width: 100%;
      height: calc(100vh - 66px);
      background: #fff;
    }
    @media (max-width: 900px) {
      #network {
        height: calc(100vh - 66px);
      }
    }
  </style>
</head>
<body>
  <div class="bar">
    <div class="row">
      <label>Top Nodes <input id="topNodes" type="number" min="0" value="0"></label>
      <label>Top Relations <input id="topRelations" type="number" min="0" value="0"></label>
      <label>Select Node
        <input id="selectedNode" type="text" list="node-list" placeholder="entity_id or name contains">
        <datalist id="node-list"></datalist>
      </label>
      <button id="applyBtn" type="button">Apply</button>
      <span class="hint">Set 0 for full top list.</span>
      <span id="meta" class="count">Loading graph.json...</span>
    </div>
  </div>
  <div id="network"></div>

  <script src="https://unpkg.com/vis-network/standalone/umd/vis-network.min.js"></script>
  <script>
    const bySupport = (a, b) => (b.chunk_count - a.chunk_count) || (b.paper_count - a.paper_count);

    let BASE_NODE_MAP = new Map();
    let BASE_EDGES = [];
    let TOTAL_NODES = 0;
    let TOTAL_EDGES = 0;
    let NET = null;

    function asInt(v) {
      const n = Number(v);
      return Number.isFinite(n) ? n : 0;
    }

    function relationCategory(relName) {
      const rel = String(relName || "").toLowerCase().trim();
      const secrete = ["secrete","secretes","secreted","secreting","produce","produces","produced","producing","production","release","releases","released","releasing","shed","sheds","shedding","export","exports","exported","exporting"];
      const recruit = ["recruit","recruits","recruited","recruiting","attract","attracts","attracted","attracting","chemoattract","chemoattracts","chemoattracted","influx","migrate","migration","migrates","migrated","migrating","infiltrate","infiltrates","infiltrated","infiltrating"];
      const inhibit = ["inhibit","inhibits","inhibited","inhibiting","inhibition","suppress","suppresses","suppressed","suppressing","suppression","block","blocks","blocked","blocking","prevent","prevents","prevented","preventing","reduce","reduces","reduced","reducing","reduction","downregulate","downregulates","downregulated","downregulating","decrease","decreases","decreased","decreasing","repress","repressed","attenuate","attenuated","impair","impaired"];
      const proliferation = ["proliferate","proliferates","proliferated","proliferating","proliferation","expand","expands","expanded","expanding","expansion","growth","grow","grows","grew","grown"];
      const activation = ["activate","activates","activated","activating","activation","stimulate","stimulates","stimulated","stimulating","trigger","triggers","triggered","triggering","induce","induces","induced","inducing","induction","upregulate","upregulates","upregulated","upregulating","increase","increases","increased","increasing","promote","promotes","promoted","promoting","enhance","enhances","enhanced","enhancing","support","supports","supported","supporting"];
      const hasAny = (arr) => arr.some(tok => rel.includes(tok));

      if (hasAny(secrete)) return "secrete";
      if (hasAny(recruit)) return "recruit";
      if (hasAny(inhibit)) return "inhibit";
      if (hasAny(proliferation)) return "proliferation";
      if (hasAny(activation)) return "activation";
      return "activation";
    }

    function hexToRgb(hex) {
      const h = String(hex).replace("#", "");
      return {
        r: parseInt(h.slice(0, 2), 16),
        g: parseInt(h.slice(2, 4), 16),
        b: parseInt(h.slice(4, 6), 16)
      };
    }

    function logFraction(value, minValue, maxValue) {
      if (maxValue <= minValue) return 1.0;
      return (Math.log1p(value) - Math.log1p(minValue)) / (Math.log1p(maxValue) - Math.log1p(minValue));
    }

    function colorWithIntensity(hexColor, frac, alphaMin, alphaMax) {
      const f = Math.max(0, Math.min(1, frac));
      const alpha = alphaMin + f * (alphaMax - alphaMin);
      const rgb = hexToRgb(hexColor);
      return `rgba(${rgb.r}, ${rgb.g}, ${rgb.b}, ${alpha.toFixed(3)})`;
    }

    function buildBase(rows) {
      const nodeMap = new Map();
      const edgeMap = new Map();

      for (const row of rows) {
        const entityId = String(row.entity_id || "").trim();
        if (!entityId) continue;
        const name = String(row.name || "").trim() || entityId;
        const stats = row.stats || {};
        nodeMap.set(entityId, {
          id: entityId,
          name,
          paper_count: asInt(stats.paper_count),
          chunk_count: asInt(stats.chunk_count || stats.chunck_count)
        });

        const rels = Array.isArray(row.relations) ? row.relations : [];
        for (const rel of rels) {
          const from = String(rel["subjective entity_id"] || "").trim();
          const to = String(rel["objective entity_id"] || "").trim();
          const relation = String(rel.relation || "").trim();
          if (!from || !to || !relation) continue;

          if (!nodeMap.has(from)) nodeMap.set(from, { id: from, name: from, paper_count: 0, chunk_count: 0 });
          if (!nodeMap.has(to)) nodeMap.set(to, { id: to, name: to, paper_count: 0, chunk_count: 0 });

          const rs = rel.stats || {};
          const category = relationCategory(relation);
          const key = `${from}|||${to}|||${category}`;
          const curr = edgeMap.get(key) || { from, to, category, relation_names: new Set(), paper_count: 0, chunk_count: 0 };
          curr.relation_names.add(relation);
          curr.paper_count += asInt(rs.paper_count);
          curr.chunk_count += asInt(rs.chunk_count || rs.chunck_count);
          edgeMap.set(key, curr);
        }
      }
      const edges = [...edgeMap.values()].map(e => ({
        ...e,
        relation_names: [...e.relation_names].sort()
      }));
      return { nodeMap, edges };
    }

    function resolveSelectedNode(needle, nodes) {
      const q = String(needle || "").trim().toLowerCase();
      if (!q) return "";

      if (nodes.has(q)) return q;

      const list = [...nodes.values()];
      for (const n of list) if (String(n.id).toLowerCase() === q) return n.id;
      for (const n of list) if (String(n.name).toLowerCase() === q) return n.id;
      for (const n of list) {
        if (String(n.id).toLowerCase().includes(q) || String(n.name).toLowerCase().includes(q)) {
          return n.id;
        }
      }
      return "";
    }

    function computeView(topNodes, topRelations, selectedNodeRaw) {
      const selectedMode = String(selectedNodeRaw || "").trim() !== "";
      const fullGraphMode = topNodes === 0 && topRelations === 0 && !selectedMode;

      let nodes = new Map(BASE_NODE_MAP);
      let filteredEdges = BASE_EDGES.filter(e => nodes.has(e.from) && nodes.has(e.to));

      if (!selectedMode && topNodes > 0 && nodes.size > topNodes) {
        const rankedNodes = [...nodes.entries()].sort((a, b) => bySupport(a[1], b[1])).slice(0, topNodes);
        nodes = new Map(rankedNodes);
        filteredEdges = filteredEdges.filter(e => nodes.has(e.from) && nodes.has(e.to));
      }

      if (selectedMode) {
        const chosen = resolveSelectedNode(selectedNodeRaw, nodes);
        if (chosen) {
          filteredEdges = filteredEdges.filter(e => e.from === chosen || e.to === chosen);
          const connected = new Set([chosen]);
          for (const e of filteredEdges) {
            connected.add(e.from);
            connected.add(e.to);
          }
          nodes = new Map([...nodes.entries()].filter(([k]) => connected.has(k)));

          if (topNodes > 0 && nodes.size > topNodes) {
            const rankedLocal = [...nodes.entries()].sort((a, b) => bySupport(a[1], b[1])).slice(0, topNodes);
            const keep = new Set(rankedLocal.map(([id]) => id));
            keep.add(chosen);
            nodes = new Map([...nodes.entries()].filter(([k]) => keep.has(k)));
            filteredEdges = filteredEdges.filter(e => nodes.has(e.from) && nodes.has(e.to));
          }
        }
      }

      if (topRelations > 0 && filteredEdges.length > topRelations) {
        const rankedEdges = [...filteredEdges].sort(bySupport).slice(0, topRelations);
        filteredEdges = rankedEdges;
        const connected = new Set();
        for (const e of rankedEdges) {
          connected.add(e.from);
          connected.add(e.to);
        }
        nodes = new Map([...nodes.entries()].filter(([k]) => connected.has(k)));
      }

      const nodePaperValues = [...nodes.values()].map(n => Math.max(0, n.paper_count));
      const minPaper = nodePaperValues.length ? Math.min(...nodePaperValues) : 1;
      const maxPaper = nodePaperValues.length ? Math.max(...nodePaperValues) : 1;
      const edgePaperValues = filteredEdges.map(e => Math.max(1, e.paper_count));
      const minEdgePaper = edgePaperValues.length ? Math.min(...edgePaperValues) : 1;
      const maxEdgePaper = edgePaperValues.length ? Math.max(...edgePaperValues) : 1;

      const visNodes = [...nodes.values()].map(n => {
        const frac = logFraction(Math.max(1, n.paper_count), Math.max(1, minPaper), Math.max(1, maxPaper));
        const outMin = fullGraphMode ? 4 : 8;
        const outMax = fullGraphMode ? 10 : 28;
        const size = outMin + frac * (outMax - outMin);
        const nodeColor = colorWithIntensity("#458B73", frac, 0.35, 0.96);

        return {
          id: n.id,
          label: fullGraphMode ? "" : `${n.id}`,
          size,
          title: `entity_id: ${n.id} | c: ${n.chunk_count} | p: ${n.paper_count}`,
          color: { background: nodeColor, border: "#458B73", highlight: { background: nodeColor, border: "#2D5E4E" } }
        };
      });

      const visEdges = filteredEdges.map(e => {
        const sign = e.category === "inhibit" ? "-" : "+";
        const frac = logFraction(Math.max(1, e.paper_count), Math.max(1, minEdgePaper), Math.max(1, maxEdgePaper));
        const edgeColor = colorWithIntensity("#458B73", frac, 0.20, 0.95);
        const signColor = sign === "+" ? "#2EAD4A" : "#E53935";
        return {
          from: e.from,
          to: e.to,
          label: fullGraphMode ? "" : sign,
          title: `c: ${e.category} | r: ${(e.relation_names || []).join("; ")} | sign: ${sign} | ch: ${e.chunk_count} | p: ${e.paper_count} | ${e.from} -> ${e.to}`,
          width: fullGraphMode ? 0.8 : 2.0,
          length: 130,
          color: { color: edgeColor, highlight: "#458B73", hover: "#458B73" },
          font: { color: signColor },
          arrows: "to"
        };
      });

      return { fullGraphMode, nodes: visNodes, edges: visEdges };
    }

    function readInputs() {
      const topNodes = Math.max(0, Number(document.getElementById("topNodes").value) || 0);
      const topRelations = Math.max(0, Number(document.getElementById("topRelations").value) || 0);
      const selectedNode = document.getElementById("selectedNode").value || "";
      return { topNodes, topRelations, selectedNode };
    }

    function renderFromInputs() {
      const { topNodes, topRelations, selectedNode } = readInputs();

      const view = computeView(topNodes, topRelations, selectedNode);

      const options = {
        nodes: {
          shape: "dot",
          font: { size: view.fullGraphMode ? 0 : 14, face: "Helvetica" },
          borderWidth: 1,
          borderWidthSelected: 2
        },
        edges: {
          smooth: { type: "dynamic" },
          font: { size: view.fullGraphMode ? 0 : 36, align: "middle", strokeWidth: 4, strokeColor: "#FFFFFF" },
          color: { inherit: false, color: "#1a1a1a", highlight: "#000000" },
          arrows: { to: { enabled: true, scaleFactor: 0.35 } },
          selectionWidth: 0,
          hoverWidth: 0
        },
        interaction: {
          hover: true,
          tooltipDelay: 150,
          navigationButtons: true
        },
        physics: {
          enabled: true,
          solver: "forceAtlas2Based",
          forceAtlas2Based: {
            gravitationalConstant: -52,
            centralGravity: 0.012,
            springLength: 170,
            springConstant: 0.05,
            damping: 0.45,
            avoidOverlap: 0.25
          },
          maxVelocity: 2.8,
          minVelocity: 0.001,
          timestep: 0.14,
          adaptiveTimestep: true,
          stabilization: { enabled: false }
        }
      };

      const data = { nodes: new vis.DataSet(view.nodes), edges: new vis.DataSet(view.edges) };
      const container = document.getElementById("network");
      if (!NET) {
        NET = new vis.Network(container, data, options);
      } else {
        NET.setData(data);
        NET.setOptions(options);
      }
      NET.startSimulation();

      document.getElementById("meta").textContent = `Total Nodes: ${TOTAL_NODES} | Total Edges: ${TOTAL_EDGES}`;
    }

    async function init() {
      const res = await fetch("./graph.json", { cache: "no-store" });
      if (!res.ok) throw new Error(`Cannot load graph.json (${res.status})`);
      const rows = await res.json();
      const base = buildBase(rows);
      BASE_NODE_MAP = base.nodeMap;
      BASE_EDGES = base.edges;
      TOTAL_NODES = BASE_NODE_MAP.size;
      TOTAL_EDGES = BASE_EDGES.length;

      const list = document.getElementById("node-list");
      const frag = document.createDocumentFragment();
      for (const n of [...BASE_NODE_MAP.values()].slice(0, 2000)) {
        const a = document.createElement("option");
        a.value = n.id;
        frag.appendChild(a);
      }
      list.appendChild(frag);

      renderFromInputs();
    }

    document.getElementById("applyBtn").addEventListener("click", () => {
      try {
        renderFromInputs();
      } catch (err) {
        document.getElementById("meta").textContent = `Error: ${err.message}`;
      }
    });

    init().catch(err => {
      document.getElementById("meta").textContent = `Error: ${err.message}`;
    });
  </script>
</body>
</html>
